제4장. 예외를 이용하지 않는 오류 처리
======================
예외를 던지는 것도 하나의 부수 효과인데, 함수적 코드에서 예외를 사용하지 않고, 오류를 함수적으로 제기하고 처리하는 기본원리를 살펴본다.

* 실패 상황과 예외를 보통의 값으로 표현할 수 있어야한다. 
  => 참조 투명성(referential transparency, RT)을 유지
* 일반적인 오류처리-복구 패턴을 추상화한 고차 함수를 작성할 수 있다는 것 
  => 오류 처리 논리의 통합(consolidation of error-handling logic) 유지

## 4.1. 예외의 장단점

* 예외의 기본 장점: 오류 처리 논리의 통합과 중앙집중화

* 예외의 주된 단점
    * 예외는 참조 투명성을 위반하고 문맥 의존성을 도입한다.
        * 참조에 투명한 표현식 => 문맥에 의존하지 않으며 지역적으로 추론
        * 참조에 투명하지 않은 표현식 => 문맥에 의존적(context-dependent) 좀 더 전역의 추론이 필요
    * 예외는 형식에 안전하지 않다.

```scala
// y가 참조에 투명하지 않음을 증명

def failingFn(i: Int): Int = {
  val y: Int = throw new Exception(“fail”)
  try {
    val x = 42 + 5
    x + y
  }
  catch { case e: Exception => 43 }
}

def failingFn2(i: Int): Int = {
  val y: Int = 
  try {
    val x = 42 + 5
    x + ((throw new Exception(“fail”): Int)
  }
  catch { case e: Exception => 43 }
}
```


```
scala> failingFn(12)
java.lang.Exception: fail!

scala> failingFn2(12)
res1: Int = 43
```


> 위의 예에서 42 + 5 의 의미는 더 큰표현식의 의존하지 않으며 그냥 영원히 47이지만, throw new Exception 문맥에 의존한다.(try 블록인지 아닌지에 따라 결과가 바뀜)


> failingFn의 형식인 Int => Int 만 보고는 이 함수가 예외를 던질 수 있다는 사실을 알 수 없다. 프로그래머가 실수로 예외 점검 코드를 추가하지 않으면 그 예외는 실행시점에서야 검출 된다.


* 예외의 대안
    * 기법 : 예외를 던지는 대신, 예외적인 조건이 발생했을 뜻하는 값을 돌려준다. 
        * 오래된 착안
        * C에서 예외 처리를 위해 오류 부호(error code)를 돌려 준다.
    * 적용 : '미리 정의해 둘 수 있는 값들'을 대표하는 새로운 일반적 형식을 도입하고, 오류의 처리와 전파에 관한 공통적인 패턴들을 고차 함수들을 이용해서 캡슐화.
    * 장점 : 형식에 완전히 안전하며, 최소한의 구문적잡음으로도 스칼라의 형식 점검기의 도움을 받아서 실수를 미리 발견할 수 있다.


## 4.2. 예외의 가능한 대안

```scala
// 예외: 빈 목록에 대해서는 평균이 정의되지 않는다.
def mean(xs: Seq[Double]): Double =
  if (xs.isEmpty)
    throw new ArithmeticException(“mean of empty list!”)
  else xs.sum / xs.length
```

### 대안 1. Double 형식의 가짜 값을 돌려주는 것 

모든 경우에 그냥 xs.sum / xs.length 를 돌려준다면 빈 목록에 대해서는 0.0/0.0을 돌려주게 되는데, 
이는 Double.NaN이다. 아니면 다른 어떤 경계 값(sentinel value)을 돌려줄 수도 있고, 상황에 따라서는 
원하는 형식의 값 대신 null일 수도 있다.)

이런 접근 방식은 예외기능이 없는 언어에서 오류를 처리하는데 흔히 사용하지만, 우리는 아래 이유로 사용하지 않는다.

1. 오류가 소리 없이 전파될 수 있다. 호출자가 이런 오류 조건의 점검을 실수로 빼먹어도 컴파일러가 경고해 주지 않으며, 그러면 이후의 코드가 제대로 작동하지 않을 수 있다. 오류가 코드의 훨씬 나중 부분에서 검출되는 경우가 많다.
2. 호출하는 쪽의 호출자가 ‘진짜’ 결과를 받았는지 점검하는 명시적 if문들로 구성된 판에 박힌 코드가 상당히 늘어난다. 
3. 다형적 코드에 적용할 수 없다. 출력 형식에 따라서는 그 형식의 경계 값을 결정하는 것이 불가능할 수도 있다.
4. 호출자에게 특별한 방침이나 호출 규약을 요구한다. mean함수를 제대로 사용하려면 호출자가 그냥 mean을 호출해서 그 결과를 사용하는 것이상의 작업을 수행해야 한다. 이런 방침은 모든 인수를 균일한 방식으로 처리해야 하는 고차 함수에 전달이 어려워진다.

```scala
def max[A](xs: Seq[A])(greater: (A,A) => Boolean): A

// A형식의 값 중 입력이 빈 순차열임을 나타내는 데 사용할 하나의 값을 정하는 것이 불가능. 
// null은 오직 기본 형식이 아닌 형식에만 유효한데, A는 Double 이나 Int같은 기본형일 수도 있다.
```    



### 대안 2. 함수가 입력을 처리할 수 없는 상황에 처했을 때 무엇을 해야 하는지 말해주는 인수를 호출자가 지정하는 것 

```scala
def mean_1(xs: IndexedSeq[Double], onEmpty: Double): Double = 
  if (xs.isEmpty) onEmpty
  else xs.sum / xs.length
```
 
* 이렇게 하면 mean은 부분함수가 아닌 완전 함수(total function) 가 된다.
* 결과가 정의되지 않는 경우의 처리 방식을 함수의 직접적인 호출자가 알고 있어야하고, 그런 경우에도 항상 하나의 Double 값을 결과로 돌려주어야 한다는 단점.
* 이는 유연하지 않고 우리에게 필요한 것은 정의되지 않은 경우가 가장 적당한 수준에서 처리되도록 그 처리 방식의 결정을 미룰 수 있게 하는 방법이다.

